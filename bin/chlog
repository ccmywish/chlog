#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : chlog.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2022-03-18>
# Last modified : <2022-03-24>
#
# chlog:
#
#   Maintain your project's Changelog on the cli.
#
# ------------------------------------------------------

CHLOG_VERSION = "1.3"

require 'date'
$today = Date.today.to_s

UNRELEASED_TITLE = "## [Unreleased](#) (#$today)"

CHLOG_TEMPLATE = <<EOT
# Changelog

#{UNRELEASED_TITLE}

<br>

## [Initialize](#) (#$today)

<br>

<hr>

This Changelog is maintained with [chlog](https://github.com/ccmywish/chlog)

EOT


def get_changelog
  file = "CHANGELOG.md"
  if File.exists? file
    return File.read file
  else
    puts "chlog: Auto generate CHANGELOG.md"
    File.write(file, CHLOG_TEMPLATE)
    return File.read file
  end
end


def help
  puts <<EOH
chlog (v#{CHLOG_VERSION}): Help maintain Changelog of your projects

usage:

  chlog          => Generate CHANGELOG.md
  chlog log      => Add log according to case or to Enhancements by default
  chlog -n log   => Add log to New features
  chlog -e log   => Add log to Enhancements
  chlog -b log   => Add log to Bug fixes
  chlog -s log   => Add log to Security
  chlog -c log   => Add log to Compatibility
  chlog -d log   => Add log to Deprecations
  chlog -r v3.14 => Release version to v3.14

EOH

end

def match_unreleased?(str)
  str =~ /^## \[Unreleased\]\(.*\) \(\d{4}-\d\d-\d\d\)/
end

def match_unreleased_fail!(str)
  unless match_unreleased?(str)
    puts "chlog: Unmathed format with chlog" 
    # "#{lns[1][1..]}"
    puts "       Unreleased version must be the third line.", ""
    exit -1
  end
end

def match_new_features?(str)
  str =~ /^### New features:/
end

def match_enhancements?(str)
  str =~ /^### Enhancements:/
end

def match_bug_fixes?(str)
  str =~ /^### Bug fixes:/
end

def match_security?(str)
  str =~ /^### Security:/
end

def match_compatibility?(str)
  str =~ /^### Compatibility:/
end

def match_deprecations?(str)
  str =~ /^### Deprecations:/
end


def next_version_index(lns_array)
  nvi = lns_array[3..].each_with_index {break _2 if _1.start_with?("## [") }
  nvi += 3
end

def next_category_index(lns_array)
  nci = lns_array[3...nvi].each_with_index {break _2 if _1.start_with?("### ") }
  
  # The not match return value is not nil!! But an array!!
  if nci.is_a(Integer)
    nci += 3
  else
    nil
  end
end


=begin
def last_list_in_main_category(cat, lns_array)

  nvi = next_version_index(lns_array)
  
  # In unreleased
  #   find where is the `cat`
  cat_i = lns_array[0..nvi].each_with_index do 
    if _1 =~ /^### #{cat}:/
      break _2
    end
    nil
  end

  if cat_i == nil
    puts "Fix this situation!!!"
  end

  # find the sub cat
  sub_cat = lns_array[cat_i+2..nvi].each_with_index do 
    break _2 if _1  !~ /^\*\*.*\*\*/
  end

  # sub cat exists
  if sub_cat.is_a?(Integer)
    sub_cat += cat_i + 2
      # write (sub_cat +2) 写在这里
  else
    # sub cat not exists
    # write list_i + 1 写在这里 ** 

  end

end
=end


#
#  ### New features:
#   
#  - xaaaaa
#  - xbbbbb
#  - xccccc    [-> this]
#
def find_main_category_last_list_item_index(lns, 
                                            main_cat_index, 
                                            first_lower_order_category_index)
  mci = main_cat_index
  nci = first_lower_order_category_index
  
  list_i = lns[mci+2..nci].each_with_index do 
    break _2 if _1  !~  /^- .*/
  end
  list_i += mci+2 - 1
end



$order_table = [
  :match_new_features?,
  :match_enhancements?,
  :match_bug_fixes?,
  :match_security?,
  :match_compatibility?,
  :match_deprecations?
]


def first_lower_order_category_index(lns_array, category_order)

  o = category_order

  nvi = next_version_index(lns_array)
  
  while o < $order_table.size
    lns_array[0...nvi].each_with_index do
      if send($order_table[o], _1)
        return _2
      end
    end
    o += 1
  end

  # Next version above 
  return (nvi - 2)
end


#
# The first of order table
# main category order: 1
#
=begin
def add_to_new_features(log)
  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  if match_new_features?(lns[4])
    # The first category in the unreleased version must be 'New features' if we do have 'New features'
    to_wr = lns[0..5].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[6..].join)
  else
    puts "chlog: Add 'New features' category"
    to_wr = lns[0..3].join + "### New features:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[3..].join)
  end
  puts "chlog: Add log to 'New features'"
end
=end

#
# A meta function: do the real work other 6 functions delegate
# 
def meta_add_to_a_category(log, main_category_order, category)

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  nvi = next_version_index(lns)
  # To find the existing category line
  has_i = lns[0...nvi].each_with_index do
    # Adjust to index of the order table 
    break _2 if send($order_table[main_category_order-1], _1)
  end

  #
  # Always update to latest time when making a log
  #
  # We must add a "\n" because every element of the array
  #   is a sentence with a trailing newline, then they can
  #   be 'joined' to a working long string
  #
  lns[2] = UNRELEASED_TITLE + "\n"

  f_l_o_c_i = first_lower_order_category_index(lns, main_category_order)

  if has_i.class != Integer
  ################################################################################
  # The main category not exists
  ################################################################################


    ########################################
    if $sub_category
    
    # Because the main category not exists,
    #   nor does the sub category
    #
    sub_cat_i = f_l_o_c_i 
    to_wr = lns[0...sub_cat_i].join + "### #{category}:\n\n" + "**#{$sub_category}**\n\n" + '  - ' + log + "\n\n"
    File.write("CHANGELOG.md", to_wr + lns[sub_cat_i..].join)
    
    puts "chlog: Add log to #{category}/#{$sub_category}"
    return 
    end # end of if $sub_category
    ########################################


    # situation: no sub category 
    
    # Not need adjust to the index of the order table
    log_loc = f_l_o_c_i
    puts "chlog: Add '#{category}' category"
    to_wr = lns[0...(log_loc)].join + "### #{category}:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[log_loc-1..].join)
  
  else
  ################################################################################
  # The main category exists
  ################################################################################
    

    ########################################
    if $sub_category
    
    # from first list item to next main cat
    #   search if sub cat already exists
    sub_cat_i = lns[has_i+2...f_l_o_c_i].each_with_index do 
      break _2 if _1 =~ /^\*\*#{$sub_category}\*\*/
    end

    if !sub_cat_i.is_a?(Integer)
    # the sub category not exists
    
      sub_cat_i = 2 + find_main_category_last_list_item_index(lns,has_i,f_l_o_c_i) 
      to_wr = lns[0...sub_cat_i].join + "**#{$sub_category}**\n\n" + '  - ' + log + "\n\n"
      File.write("CHANGELOG.md", to_wr + lns[sub_cat_i..].join)
    else
    # the sub category exists  

      sub_cat_i +=  has_i+2
      to_wr = lns[0..sub_cat_i+1].join + '  - ' + log + "\n"
      File.write("CHANGELOG.md", to_wr + lns[sub_cat_i+2..].join)
    end

    puts "chlog: Add log to #{category}/#{$sub_category}"
    return 
    end # end of if $sub_category
    ########################################



    # situation: no sub category 

    to_wr = lns[0..has_i+1].join + '- ' + log + "\n"
    
    # main category list should be separated with
    # sub category
    if lns[has_i+2] =~ /\*\*.*/
      to_wr += "\n"
    end
    File.write("CHANGELOG.md", to_wr + lns[has_i+2..].join)
  end
  puts "chlog: Add log to #{category}"
end

#
# main category order: 1
#
def add_to_new_features(log)
  meta_add_to_a_category(log, 1, "New features")
end

#
# main category order: 2
#
def add_to_enhancements(log)
  meta_add_to_a_category(log, 2, "Enhancements")
end

#
# main_category_order: 3
#
def add_to_bug_fixes(log)
  meta_add_to_a_category(log, 3, "Bug fixes")
end

#
# main_category_order: 4
#
def add_to_security(log)
  meta_add_to_a_category(log, 4, "Security")
end

#
# main_category_order: 5
#
def add_to_compatibility(log)
  meta_add_to_a_category(log, 5, "Compatibility")
end


#
# The last of order table
# main_category_order: 6
#
def add_to_deprecations(log)
  meta_add_to_a_category(log, 6, "Deprecations")
end
=begin
def add_to_deprecations(log)
  content = get_changelog
  lns = content.lines

  nvi = next_version_index(lns)
  dep_i = lns[0..nvi].each_with_index { break _2 if match_deprecations?(_1) }

  if dep_i.class != Integer
    puts "chlog: Add 'Deprecations' category"
    to_wr = lns[0..(nvi-3)].join + "### Deprecations:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[(nvi-3)..].join)
  else
    # 'Deprecations' exists
    to_wr = lns[0..dep_i+1].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[dep_i+2..].join)
  end
  puts "chlog: Add to Deprecations"
end
=end

def release_new_version(ver)
  if ver.nil?
    puts "chlog: No version supplied! "
    puts "       Use chlog -r <version>!",""
    exit 1
  end

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  header = <<EOF
# Changelog

## [Unreleased](#) (#$today)

<br>

EOF
  
  new_version = "## [#{ver}](#) (#$today)\n"
  new_cont = header + new_version + lns[3..].join('')
  File.write("CHANGELOG.md", new_cont)
  puts "Release #{ver} in changelog!"
end


def add_log_sensitive(log)

  # Be careful the when statements order
  # Match the case you want first
  case log
  when /deprecat/i, /remove/i, /^not/i                 then add_to_deprecations(log)
  when /new/i, /new feature/i                          then add_to_new_features(log)
  when /feature/i, /support/i, /add/i, /update/i       then add_to_enhancements(log)
  when /fix/i, /repair/i, /bug/i, /problem/i, /issue/i then add_to_bug_fixes(log)
  when /compatible/i, /compatibility/i                 then add_to_compatibility(log)
  when /security/i, /secure/i, /cve/i                  then add_to_security(log)
  else
    add_to_enhancements(log)
  end
end


def with_git
  gitlog = `git log --oneline -n 1`
  log = gitlog.split(' ')
  log = log[1..].join(' ')
  add_log_sensitive(log)
end


#############
#    main
#############

if $*.size == 0
  if File.exists? "CHANGELOG.md"
    puts "chlog: Already exists Changelog"
    puts "       Use chlog -h to see options"
  else
    get_changelog
  end
  exit
end

action = $*[0]
if $*[1] =~ /--(.*)/
  puts "-> DEBUG: #$1"
  $sub_category = $1 
  log = $*[2..].join(' ')
else
  $sub_category = nil
  log = $*[1..].join(' ')
end


case action
when ?h, "-h" then help()
when ?n, "-n" then add_to_new_features(log)
when ?e, "-e" then add_to_enhancements(log)
when ?b, "-b" then add_to_bug_fixes(log)
when ?s, "-s" then add_to_security(log)
when ?c, "-c" then add_to_compatibility(log)
when ?d, "-d" then add_to_deprecations(log)
when ?r, "-r" then release_new_version($*[1])
else
  puts "chlog: Unknown option!"
  help
  # add_log_sensitive $*[0..].join(' ')
end

