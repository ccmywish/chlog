#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : chlog.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2022-03-18>
# Last modified : <2022-03-24>
#
# chlog:
#
#   Maintain your project's Changelog on the cli.
#
# ------------------------------------------------------

CHLOG_VERSION = "1.4"

require 'date'
$today = Date.today.to_s

UNRELEASED_TITLE = "## [Unreleased](#) (#$today)"

CHLOG_TEMPLATE = <<EOT
# Changelog

#{UNRELEASED_TITLE}

<br>

## [Initialize](#) (#$today)

<br>

<hr>

This Changelog is maintained with [chlog](https://github.com/ccmywish/chlog)

EOT


def get_changelog
  file = "CHANGELOG.md"
  if File.exists? file
    return File.read file
  else
    puts "chlog: Auto generate CHANGELOG.md"
    File.write(file, CHLOG_TEMPLATE)
    return File.read file
  end
end


def help
  puts <<EOH
chlog (v#{CHLOG_VERSION}): Help maintain Changelog of your projects

usage:

  chlog                  => Generate CHANGELOG.md
  chlog -g (-m) (--sub)  => Reuse last commit log (m category / sub category)
  chlog (--sub) log      => Determine category, add log (default Enhancements) (/ sub category)
  chlog -n (--sub) log   => Add log to New features (/ sub category)
  chlog -e (--sub) log   => Add log to Enhancements (/ sub category)
  chlog -b (--sub) log   => Add log to Bug fixes    (/ sub category)
  chlog -s (--sub) log   => Add log to Security     (/ sub category)
  chlog -c (--sub) log   => Add log to Compatibility(/ sub category)
  chlog -d (--sub) log   => Add log to Deprecations (/ sub category)
  chlog -r v3.14         => Release version to v3.14

EOH

end

def match_unreleased?(str)
  str =~ /^## \[Unreleased\]\(.*\) \(\d{4}-\d\d-\d\d\)/
end

def match_unreleased_fail!(str)
  unless match_unreleased?(str)
    puts "chlog: Unmathed format with chlog" 
    # "#{lns[1][1..]}"
    puts "       Unreleased version must be the third line.", ""
    exit -1
  end
end

def match_new_features?(str)
  str =~ /^### New features:/
end

def match_enhancements?(str)
  str =~ /^### Enhancements:/
end

def match_bug_fixes?(str)
  str =~ /^### Bug fixes:/
end

def match_security?(str)
  str =~ /^### Security:/
end

def match_compatibility?(str)
  str =~ /^### Compatibility:/
end

def match_deprecations?(str)
  str =~ /^### Deprecations:/
end


def next_version_index(lns_array)
  nvi = lns_array[3..].each_with_index {break _2 if _1.start_with?("## [") }
  nvi += 3
end

def next_category_index(lns_array)
  nci = lns_array[3...nvi].each_with_index {break _2 if _1.start_with?("### ") }
  
  # The not match return value is not nil!! But an array!!
  if nci.is_a(Integer)
    nci += 3
  else
    nil
  end
end


=begin
def last_list_in_main_category(cat, lns_array)

  nvi = next_version_index(lns_array)
  
  # In unreleased
  #   find where is the `cat`
  cat_i = lns_array[0..nvi].each_with_index do 
    if _1 =~ /^### #{cat}:/
      break _2
    end
    nil
  end

  if cat_i == nil
    puts "Fix this situation!!!"
  end

  # find the sub cat
  sub_cat = lns_array[cat_i+2..nvi].each_with_index do 
    break _2 if _1  !~ /^\*\*.*\*\*/
  end

  # sub cat exists
  if sub_cat.is_a?(Integer)
    sub_cat += cat_i + 2
      # write (sub_cat +2) 写在这里
  else
    # sub cat not exists
    # write list_i + 1 写在这里 ** 

  end

end
=end


#
#  ### New features:
#   
#  - xaaaaa
#  - xbbbbb
#  - xccccc    [-> this]
#
def find_main_category_last_list_item_index(lns, 
                                            main_cat_index, 
                                            first_lower_order_category_index)
  mci = main_cat_index
  nci = first_lower_order_category_index
  
  list_i = lns[mci+2..nci].each_with_index do 
    break _2 if _1  !~  /^- .*/
  end
  list_i += mci+2 - 1
end



$order_table = [
  :match_new_features?,
  :match_enhancements?,
  :match_bug_fixes?,
  :match_security?,
  :match_compatibility?,
  :match_deprecations?
]


def first_lower_order_category_index(lns_array, category_order)

  o = category_order

  nvi = next_version_index(lns_array)
  
  while o < $order_table.size
    lns_array[0...nvi].each_with_index do
      if send($order_table[o], _1)
        return _2
      end
    end
    o += 1
  end

  # Next version above 
  return (nvi - 2)
end


#
# The first of order table
# main category order: 1
#
=begin
def add_to_new_features(log)
  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  if match_new_features?(lns[4])
    # The first category in the unreleased version must be 'New features' if we do have 'New features'
    to_wr = lns[0..5].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[6..].join)
  else
    puts "chlog: Add 'New features' category"
    to_wr = lns[0..3].join + "### New features:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[3..].join)
  end
  puts "chlog: Add log to 'New features'"
end
=end

#
# A meta function: do the real work other 6 functions delegate
#
# This function detect the main category, and then handle the 
# sub category.
# 
def meta_add_to_a_category(log, main_category_order, category)

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  nvi = next_version_index(lns)
  # To find the existing category line
  main_cat_i = lns[0...nvi].each_with_index do
    # Adjust to index of the order table 
    break _2 if send($order_table[main_category_order-1], _1)
  end

  #
  # Always update to latest time when making a log
  #
  # We must add a "\n" because every element of the array
  #   is a sentence with a trailing newline, then they can
  #   be 'joined' to a working long string
  #
  lns[2] = UNRELEASED_TITLE + "\n"

  f_l_o_c_i = first_lower_order_category_index(lns, main_category_order)

  if main_cat_i.class != Integer
  ################################################################################
  # The main category not exists
  ################################################################################


    ########################################
    if $sub_category
    
    # Because the main category not exists,
    #   nor does the sub category
    #
    sub_cat_i = f_l_o_c_i 
    to_wr = lns[0...sub_cat_i].join + "### #{category}:\n\n" + "**#{$sub_category}**\n\n" + '  - ' + log + "\n\n"
    File.write("CHANGELOG.md", to_wr + lns[sub_cat_i..].join)
    
    puts "chlog: Add log to #{category}/#{$sub_category}"
    return 
    end # end of if $sub_category
    ########################################


    # situation: no sub category 
    
    # Not need adjust to the index of the order table
    log_loc = f_l_o_c_i
    puts "chlog: Add '#{category}' category"
    to_wr = lns[0...(log_loc)].join + "### #{category}:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[log_loc-1..].join)
  
  else
  ################################################################################
  # The main category exists
  ################################################################################
    

    ########################################
    if $sub_category
    
    # from first list item to next main cat
    #   search if sub cat already exists
    sub_cat_i = lns[main_cat_i+2...f_l_o_c_i].each_with_index do 
      break _2 if _1 =~ /^\*\*#{$sub_category}\*\*/
    end

    if !sub_cat_i.is_a?(Integer)
    # the sub category not exists
    
      sub_cat_i = 2 + find_main_category_last_list_item_index(lns,main_cat_i,f_l_o_c_i) 
      to_wr = lns[0...sub_cat_i].join + "**#{$sub_category}**\n\n" + '  - ' + log + "\n\n"
      File.write("CHANGELOG.md", to_wr + lns[sub_cat_i..].join)
    else
    # the sub category exists  

      sub_cat_i +=  main_cat_i+2
      to_wr = lns[0..sub_cat_i+1].join + '  - ' + log + "\n"
      File.write("CHANGELOG.md", to_wr + lns[sub_cat_i+2..].join)
    end

    puts "chlog: Add log to #{category}/#{$sub_category}"
    return 
    end # end of if $sub_category
    ########################################



    # situation: no sub category 

    to_wr = lns[0..main_cat_i+1].join + '- ' + log + "\n"
    
    # main category list should be separated with
    # sub category
    if lns[main_cat_i+2] =~ /\*\*.*/
      to_wr += "\n"
    end
    File.write("CHANGELOG.md", to_wr + lns[main_cat_i+2..].join)
  end
  puts "chlog: Add log to #{category}"
end


#
# main category order: 1
#
def add_to_new_features(log)
  meta_add_to_a_category(log, 1, "New features")
end

#
# main category order: 2
#
def add_to_enhancements(log)
  meta_add_to_a_category(log, 2, "Enhancements")
end

#
# main_category_order: 3
#
def add_to_bug_fixes(log)
  meta_add_to_a_category(log, 3, "Bug fixes")
end

#
# main_category_order: 4
#
def add_to_security(log)
  meta_add_to_a_category(log, 4, "Security")
end

#
# main_category_order: 5
#
def add_to_compatibility(log)
  meta_add_to_a_category(log, 5, "Compatibility")
end

#
# The last of order table
# main_category_order: 6
#
def add_to_deprecations(log)
  meta_add_to_a_category(log, 6, "Deprecations")
end

=begin
def add_to_deprecations(log)
  content = get_changelog
  lns = content.lines

  nvi = next_version_index(lns)
  dep_i = lns[0..nvi].each_with_index { break _2 if match_deprecations?(_1) }

  if dep_i.class != Integer
    puts "chlog: Add 'Deprecations' category"
    to_wr = lns[0..(nvi-3)].join + "### Deprecations:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[(nvi-3)..].join)
  else
    # 'Deprecations' exists
    to_wr = lns[0..dep_i+1].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[dep_i+2..].join)
  end
  puts "chlog: Add to Deprecations"
end
=end


def release_new_version(ver)
  if ver.nil?
    puts "chlog: No version supplied! "
    puts "       Use chlog -r <version>!",""
    exit 1
  end

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  header = <<EOF
# Changelog

## [Unreleased](#) (#$today)

<br>

EOF
  
  new_version = "## [#{ver}](#) (#$today)\n"
  new_cont = header + new_version + lns[3..].join('')
  File.write("CHANGELOG.md", new_cont)
  puts "Release #{ver} in changelog!"
end


def add_log_sensitive(log)

  # Be careful the when statements order
  # Match the case you want first
  case log
  when /deprecat/i, /remove/i, /^not/i                 then add_to_deprecations(log)
  when /^new/i, /^add/i, /new feature/i, /^support/i   then add_to_new_features(log)
  when /feature/i, /update/i                           then add_to_enhancements(log)
  when /fix/i, /repair/i, /bug/i, /problem/i, /issue/i then add_to_bug_fixes(log)
  when /compatible/i, /compatibility/i                 then add_to_compatibility(log)
  when /security/i, /secure/i, /cve/i                  then add_to_security(log)
  else
    add_to_enhancements(log)
  end
end


#
# reuse git commit log
#
def add_with_git(first, second)

  main_category = nil

  if first =~ /^-([nebscd])$/
    main_category = $1
  elsif first =~ /^--(.*)/
    $sub_category = $1
  end

  if second =~ /^-([nebscd])$/
    main_category = $1
  elsif second =~ /^--(.*)/
    $sub_category = $1
  end


  gitlog = `git log --oneline -n 1`
  log = gitlog.split(' ')
  log = log[1..].join(' ')
  puts "last commit: #{log}"

  if $sub_category.nil?
    puts "What sub category? Input or leave it blank"
    print '>'
    sub = STDIN.gets.chomp
    case sub
    when ''
      $sub_category = nil
    else
      $sub_category = sub
    end
  end

  if main_category.nil?
    puts "What main category? Input number or leave it blank to auto determine"
    puts <<~EOC
    ----------------
    1. New features
    2. Enhancements
    3. Bug fixes
    4. Security
    5. Compatibility
    6. Deprecations
    ----------------
    EOC
  
    print '>'
    case STDIN.gets.chomp
    when '1'      then add_to_new_features(log)
    when '2'      then add_to_enhancements(log)
    when '3'      then add_to_bug_fixes(log)
    when '4'      then add_to_security(log)
    when '5'      then add_to_compatibility(log)
    when '6'      then add_to_deprecations(log)
    else
      add_log_sensitive(log)
    end
  else
    tbl = {
      'n' => :add_to_new_features,
      'e' => :add_to_enhancements,
      'b' => :add_to_bug_fixes,
      's' => :add_to_security,
      'c' => :add_to_compatibility,
      'd' => :add_to_deprecations
    }
    send(tbl[main_category], log)
  end

  # Auto commit
  files = `git diff --exit-code --name-only`
  files = files.split
  if (files.size == 1) && (files[0] == "CHANGELOG.md")
    puts "chlog: Able to commit the new Changelog, input y/yes/blank to agree, or others to refuse"
    print '>'
    case STDIN.gets.chomp.downcase
    when '', 'yes', 'y'
      system("git add ./CHANGELOG.md && git commit -m 'Update the Changelog' ")
    else
      "do nothing" 
    end
  end
end


#############
#    main
#############

if $*.size == 0
  if File.exists? "CHANGELOG.md"
    puts "chlog: Already exists Changelog"
    puts "       Use chlog -h to see options"
  else
    get_changelog
  end
  exit
end

action = $*[0]
if $*[1] =~ /--(.*)/
  puts "-> DEBUG: #$1"
  $sub_category = $1 
  log = $*[2..].join(' ')
else
  $sub_category = nil
  log = $*[1..].join(' ')
end


case action
when ?h, "-h", "--help" then help()
when ?n, "-n" then add_to_new_features(log)
when ?e, "-e" then add_to_enhancements(log)
when ?b, "-b" then add_to_bug_fixes(log)
when ?s, "-s" then add_to_security(log)
when ?c, "-c" then add_to_compatibility(log)
when ?d, "-d" then add_to_deprecations(log)
when ?r, "-r" then release_new_version($*[1])
when ?d, "-g" then add_with_git($*[1], $*[2])
else
  if action =~ /^-[^-]*$/
    puts "chlog: Unknown option!"
    exit 1
  else
    if $*[0] =~ /^--(.*)/
      $sub_category = $1 
      log = $*[1..].join(' ')
    else
      $sub_category = nil
      log = $*[0..].join(' ')
    end
    puts "chlog: Auto determine log category"
    add_log_sensitive(log)
  end
end

