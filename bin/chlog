#!/usr/bin/env ruby
# ------------------------------------------------------
# File          : chlog.rb
# Authors       : ccmywish <ccmywish@qq.com>
# Created on    : <2022-03-18>
# Last modified : <2022-03-19>
#
# chlog:
#
#   Maintain your project's changelog
#
# ------------------------------------------------------

CHLOG_VERSION = "1.1"

require 'date'
$today = Date.today.to_s

$unreleased_title = "## [Unreleased](#) (#$today)"

$chlog_template = <<EOT
# Changelog

#$unreleased_title

<br>

## [Initialize](#) (#$today)

<br>

<hr>

This Changelog is maintained with [chlog](https://github.com/ccmywish/chlog)

EOT

def get_changelog
  file = "CHANGELOG.md"
  if File.exists? file
    return File.read file
  else
    puts "chlog: Auto generate CHANGELOG.md"
    File.write(file, $chlog_template)
    return File.read file
  end
end

def help
  puts <<EOH
chlog (v#{CHLOG_VERSION}): Help maintain Changelog of your projects

usage:

  chlog          => Generate CHANGELOG.md
  chlog log      => Add log according to case or to Enhancements by default
  chlog -n log   => Add log to New features
  chlog -e log   => Add log to Enhancements
  chlog -b log   => Add log to Bug fixes
  chlog -s log   => Add log to Security
  chlog -c log   => Add log to Compatibility
  chlog -d log   => Add log to Deprecations
  chlog -r v3.14 => Release version to v3.14

EOH

end

def match_unreleased?(str)
  str =~ /^## \[Unreleased\]\(.*\) \(\d{4}-\d\d-\d\d\)/
end

def match_unreleased_fail!(str)
  unless match_unreleased?(str)
    puts "chlog: Unmathed format with chlog" 
    # "#{lns[1][1..]}"
    puts "       Unreleased version must be the third line.", ""
    exit -1
  end
end

def match_new_features?(str)
  str =~ /^### New features:/
end

def match_enhancements?(str)
  str =~ /^### Enhancements:/
end

def match_bug_fixes?(str)
  str =~ /^### Bug fixes:/
end

def match_deprecations?(str)
  str =~ /^### Deprecations:/
end

def match_security?(str)
  str =~ /^### Security:/
end

def match_compatibility?(str)
  str =~ /^### Compatibility:/
end


def next_version_index(lns_array)
  nvi = lns_array[3..].each_with_index {break _2 if _1.start_with?("## [") }
  nvi += 3
end

def next_category_index(lns_array)
  nci = lns_array[3...nvi].each_with_index {break _2 if _1.start_with?("### ") }
  
  # The not match return value is not nil!! But an array!!
  if nci.is_a(Integer)
    nci += 3
  else
    nil
  end
end


def first_lower_order_category_index(lns_array, category_order)

  o = category_order

  order_table = [
    :match_new_features?,
    :match_enhancements?,
    :match_bug_fixes?,
    :match_security?,
    :match_compatibility?,
    :match_deprecations?
  ]

  nvi = next_version_index(lns_array)
  
  while o < order_table.size
    lns_array[0...nvi].each_with_index do
      if send(order_table[o], _1)
        return _2
      end
    end
    o += 1
  end

  # Next version above 
  return (nvi - 2)
end


#
#
#
def add_to_new_features(log)
  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  if match_new_features?(lns[4])
    # The first category in the unreleased version must be 'New features' if we do have 'New features'
    to_wr = lns[0..5].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[6..].join)
  else
    puts "chlog: Add 'New features' category"
    to_wr = lns[0..3].join + "### New features:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[3..].join)
  end
  puts "chlog: Add log to 'New features'"
end


#
# main category order: 2
#
def add_to_enhancements(log)

  main_category_order =  2

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  nvi = next_version_index(lns)

  en_i = lns[0...nvi].each_with_index { break _2 if match_enhancements?(_1) }

  if en_i.class != Integer
    log_loc = first_lower_order_category_index(lns, main_category_order)
    puts "chlog: Add 'New features' category"
    to_wr = lns[0...(log_loc)].join + "### Enhancements:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[log_loc..].join)
  else
    # 'Enhancements' exists
    to_wr = lns[0..en_i+1].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[en_i+2..].join)
  end
  puts "chlog: Add to Enhancements"
end



#
#
#
def add_to_bug_fixes(log)
  content = get_changelog
  lns = content.lines

  unless match_unreleased? lns[2]
    to_wr = $unreleased_title + "\n\n"
    to_wr += "**Bug fixes:**\n\n" + '- ' + log + "\n\n<br>\n\n"

    File.write("CHANGELOG.md", "# Changelog\n\n" + to_wr + lns[2..].join)
  else
    # next index
    ni = lns[3..].each_with_index {break _2 if _1.start_with?("## [") }
    ni += 3

    bug_i = lns[0..ni].each_with_index { break _2 if match_bug_fixes?(_1) }

    # The not match return value is not nil!! But an array!!
    if bug_i.class != Integer
      puts "chlog: Add 'Bug fixes' category"
      to_wr = lns[0..(ni-3)].join + "### Bug fixes:\n\n" + '- ' + log + "\n"
      File.write("CHANGELOG.md", to_wr + lns[(ni-3)..].join)
    else
      # Buf fix exists
      to_wr = lns[0..bug_i+1].join + '- ' + log + "\n"
      File.write("CHANGELOG.md", to_wr + lns[bug_i+2..].join)
    end

  end

  puts "chlog: Add to Bug fixes"
end


#
#
#
def add_to_security(log)
end

#
#
#
def add_to_compatibility(log)
end

#
#
#
def add_to_deprecations(log)
  content = get_changelog
  lns = content.lines

  nvi = next_version_index(lns)
  dep_i = lns[0..nvi].each_with_index { break _2 if match_deprecations?(_1) }

  if dep_i.class != Integer
    puts "chlog: Add 'Deprecations' category"
    to_wr = lns[0..(nvi-3)].join + "### Deprecations:\n\n" + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[(nvi-3)..].join)
  else
    # 'Deprecations' exists
    to_wr = lns[0..dep_i+1].join + '- ' + log + "\n"
    File.write("CHANGELOG.md", to_wr + lns[dep_i+2..].join)
  end
  puts "chlog: Add to Deprecations"
end



def release_new_version(ver)
  if ver.nil?
    puts "chlog: No version supplied! "
    puts "       Use chlog -r <version>!",""
    exit 1
  end

  content = get_changelog
  lns = content.lines

  match_unreleased_fail!(lns[2])

  header = <<EOF
# Changelog

## [Unreleased](#) (#$today)

<br>

EOF
  
  new_version = "## [#{ver}](#) (#$today)\n"
  new_cont = header + new_version + lns[3..].join('')
  File.write("CHANGELOG.md", new_cont)
  puts "Release #{ver} in changelog!"
end


def add_log_sensitive(log)

  # Be careful the when statements order
  # Match the case you want first
  case log
  when /deprecat/i, /remove/i, /^not/i                 then add_to_deprecations(log)
  when /new/i, /new feature/i                          then add_to_enhancements(log)
  when /feature/i, /support/i, /add/i, /update/i       then add_to_enhancements(log)
  when /fix/i, /repair/i, /bug/i, /problem/i, /issue/i then add_to_bug_fixes(log)
  when /compatible/i, /compatibility/i                 then add_to_compatibility(log)
  when /security/i, /secure/i, /cve/i                  then add_to_security(log)
  else
    add_to_enhancements(log)
  end
end

def with_git
  gitlog = `git log --oneline -n 1`
  log = gitlog.split(' ')
  log = log[1..].join(' ')
  add_log_sensitive(log)
end


#############
#    main
#############

if $*.size == 0
  if File.exists? "CHANGELOG.md"
    puts "chlog: Already exists Changelog"
    puts "       Use chlog -h to see options"
  else
    get_changelog
  end
  exit
end

action = $*[0]
log = $*[1..].join(' ')

case action
when ?h, "-h" then help()
when ?a, "-n" then add_to_new_features(log)
when ?e, "-e" then add_to_enhancements(log)
when ?b, "-b" then add_to_bug_fixes(log)
when ?s, "-s" then add_to_security(log)
when ?s, "-s" then add_to_compatibility(log)
when ?d, "-d" then add_to_deprecations(log)
when ?r, "-r" then release_new_version($*[1])
else
  help
  # add_log_sensitive $*[0..].join(' ')
end

